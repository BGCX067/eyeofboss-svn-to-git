/*
 * Schedule.java
 *
 * Created on 9 maj 2008, 11:04
 */

package customComponents;

import java.awt.Color;
import java.awt.Dimension;
import javax.swing.JPanel;
import java.util.*;
import javax.swing.JFrame;


/**
 *
 * @author Łukasz Spintzyk
 */
public class Schedule extends JPanel {

    /** Creates new form Bean Schedule */    
    public Schedule() {
        initComponents();
        dataModel=new CalendarDataModel();
        this.scheduleTable.setModel(dataModel);
        this.scheduleTable.setDefaultRenderer(CalendarDay.class,new ScheduleDefaultCellRenderer());
        this.scheduleTable.setDefaultEditor(CalendarDay.class, new ScheduleCellEditor(10));
    }

    /**
     * Funkcja ustawia zawartosć monthComboBoxa
     *
     * @param String[] item to tablica miesięcy jakie mogą być pokazane
     */
    public void setYearComboBox(Integer[] items){
        for(Integer item: items){
            if (1970<item)
                yearComboBox.addItem(item);
        }
    }
    
   
    public void setMonthComboBox(Integer[] items){
        for(Integer item: items){
            if ((item>0) && (item<=12))
                monthComboBox.addItem(monthNames[item-1]);
        }
    }
    public void addToMonthComboBox(Integer item){
        if ((item>0) && (item<=12)){
            //sprawdzenie czy już takiego elementu nie ma
            boolean isnew=true;
            for (int i=0;i<monthComboBox.getItemCount();i++){
                if (monthComboBox.getItemAt(i).equals(monthNames[item-1])) isnew=false;
            }
            if (isnew)                
                monthComboBox.addItem(monthNames[item-1]);
        }
    }
    public void addToYearComboBox(Integer item){
        if (1970<item)
        {   
            //sprawdzenie czy już takiego elementu nie ma
            
            for (int i=0;i<yearComboBox.getItemCount();i++){
                if (((Integer)yearComboBox.getItemAt(i)).equals(item))
                    return;
                
                else break;
            }
            yearComboBox.addItem(item);
        }
    }
        
    public CalendarDataModel getCalendarDataModel(){
        return dataModel;
    }
    public void setCalendarDataModel(CalendarDataModel model){
        dataModel=model;
    }  

    public void clearSchedule(){
        if (dataModel==null) return;
        CalendarDay [][]days=dataModel.getDays();
        if (days==null) return;
           for (int i=0;i<days.length;i++)
                for (int j=0;j<days[i].length;j++){
                    days[i][j].setYearMonthDay(0,0,0);
                    days[i][j].freeEvents();
                }
        dataModel.countDays();
    }
    
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        scheduleLabel = new javax.swing.JLabel();
        monthLabel = new javax.swing.JLabel();
        monthComboBox = new javax.swing.JComboBox();
        yearLabel = new javax.swing.JLabel();
        yearComboBox = new javax.swing.JComboBox();
        scheduleTableScrollPane = new javax.swing.JScrollPane();
        scheduleTable = new javax.swing.JTable();
        shiftComboBox = new javax.swing.JComboBox();
        zmianaLabel = new javax.swing.JLabel();

        setName("Form"); // NOI18N

        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(logIn.LogIn.class).getContext().getResourceMap(Schedule.class);
        scheduleLabel.setText(resourceMap.getString("scheduleLabel.text")); // NOI18N
        scheduleLabel.setName("scheduleLabel"); // NOI18N

        monthLabel.setText(resourceMap.getString("monthLabel.text")); // NOI18N
        monthLabel.setName("monthLabel"); // NOI18N

        monthComboBox.setName("monthComboBox"); // NOI18N
        monthComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                monthComboBoxActionPerformed(evt);
            }
        });

        yearLabel.setText(resourceMap.getString("yearLabel.text")); // NOI18N
        yearLabel.setName("yearLabel"); // NOI18N

        yearComboBox.setName("yearComboBox"); // NOI18N
        yearComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                yearComboBoxActionPerformed(evt);
            }
        });

        scheduleTableScrollPane.setName("scheduleTableScrollPane"); // NOI18N

        scheduleTable.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        scheduleTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null}
            },
            new String [] {
                "P", "W", "Ś", "C", "P", "S", "N"
            }
        ));
        scheduleTable.setCellSelectionEnabled(true);
        scheduleTable.setName("scheduleTable"); // NOI18N
        scheduleTable.setRowHeight(20);
        scheduleTable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        scheduleTable.setUpdateSelectionOnSort(false);
        scheduleTable.setVerifyInputWhenFocusTarget(false);
        scheduleTable.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                scheduleTableComponentResized(evt);
            }
        });
        scheduleTableScrollPane.setViewportView(scheduleTable);

        shiftComboBox.setName("shiftComboBox"); // NOI18N

        zmianaLabel.setText(resourceMap.getString("zmianaLabel.text")); // NOI18N
        zmianaLabel.setName("zmianaLabel"); // NOI18N

        shiftComboBox.setVisible(false);
        zmianaLabel.setVisible(false);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(scheduleLabel)
            .addGroup(layout.createSequentialGroup()
                .addGap(6, 6, 6)
                .addComponent(monthLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(monthComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(24, 24, 24)
                .addComponent(yearLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(yearComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 68, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 29, Short.MAX_VALUE)
                .addComponent(zmianaLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(shiftComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addComponent(scheduleTableScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 484, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(scheduleLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(yearLabel)
                    .addComponent(yearComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(monthLabel)
                    .addComponent(monthComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(shiftComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(zmianaLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(scheduleTableScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

private void scheduleTableComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_scheduleTableComponentResized
    Dimension a=scheduleTableScrollPane.getSize();
    if ((a.height/6) < 30) a.height=30;
    else a.height=(a.height -20)/6;
    scheduleTable.setRowHeight(a.height);
}//GEN-LAST:event_scheduleTableComponentResized

private void monthComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_monthComboBoxActionPerformed
    System.out.println("MONTH Action Performed");
    String m=(String)monthComboBox.getSelectedItem();
    for(int i=0;i<monthNames.length;i++)
        if (m.equals(monthNames[i])) {
            dataModel.setMonth(i+1);
            scheduleTable.repaint();
            break;
        }

}//GEN-LAST:event_monthComboBoxActionPerformed


private void yearComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_yearComboBoxActionPerformed
    System.out.println("YEAR Action Performed");
    dataModel.setYear((Integer)yearComboBox.getSelectedItem());
    scheduleTable.repaint();
}//GEN-LAST:event_yearComboBoxActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    public javax.swing.JComboBox monthComboBox;
    public javax.swing.JLabel monthLabel;
    public javax.swing.JLabel scheduleLabel;
    public javax.swing.JTable scheduleTable;
    public javax.swing.JScrollPane scheduleTableScrollPane;
    public javax.swing.JComboBox shiftComboBox;
    public javax.swing.JComboBox yearComboBox;
    public javax.swing.JLabel yearLabel;
    public javax.swing.JLabel zmianaLabel;
    // End of variables declaration//GEN-END:variables
    private CalendarDataModel dataModel;
    public static final String[] monthNames={"Styczeń","Luty","Marzec","Kwiecień","Maj","Czerwiec",
                        "Lipiec","Sierpień","Wrzesień","Październik","Listopad","Grudzień"};

    

    
    /**
     * Klasa przedstawia model danych w Kalendarzu
     */
    public class CalendarDataModel extends javax.swing.table.DefaultTableModel{
        /** Tablica na wartości miesiąca */
        private CalendarDay[][] days;
        /** Jaki miesiąc wyswietlić*/
        private int month; 
        /** Jaki rok wyswietlić */
        private int year;
        
        private boolean editable=false;
        public CalendarDataModel(){
            String[] colNames={"Nd","Pn","Wt","Śr","Cz","Pt","Sob"};
            setColumnIdentifiers(colNames);
            days=new CalendarDay[6][7];
            for (int i=0; i< days.length;i++)
                for (int j=0;j<days[i].length;j++)
                    days[i][j]=new CalendarDay();
            //domyslne ustawienie roku i miesiąca
            Calendar cal=Calendar.getInstance();
            year=cal.get(Calendar.YEAR);
            month=cal.get(Calendar.MONTH);

            countDays();
 
            for (int i=0; i < days.length;i++)
                this.addRow(days[i]);
        }

        @Override
        public boolean isCellEditable(int row, int column) {
            return isEditable();
        }
        
        
        
        /**
         * Funkcja ustawia wartości tablicy days i na wartości dnia miesiąca,
         * na podstawie zmiennych year i month
         */
        private void countDays(){

            GregorianCalendar cal=new GregorianCalendar(getYear(), getMonth()-1, 1);
            

            for (int i=0;i<getDays().length;i++)
                for (int j=0;j<getDays()[i].length;j++){
                    getDays()[i][j].setYearMonthDay(0,0,0);
                    getDays()[i][j].freeEvents();
                }
            cal.setFirstDayOfWeek(Calendar.SUNDAY);

            
            //ustawienie dni z tego miesiąca
            cal.set(getYear(), getMonth()-1, 1);
            
            for (int i=cal.getMinimum(Calendar.DAY_OF_MONTH);i <= cal.getActualMaximum(Calendar.DAY_OF_MONTH); i++){
                cal.set(getYear(), getMonth()-1,i);
                getDays()[cal.get(Calendar.WEEK_OF_MONTH)][cal.get(Calendar.DAY_OF_WEEK)-1].setYearMonthDay(getYear(), getMonth(), i);
                if (cal.get(Calendar.DAY_OF_WEEK)==Calendar.SUNDAY) getDays()[cal.get(Calendar.WEEK_OF_MONTH)][cal.get(Calendar.DAY_OF_WEEK)-1].setDayColor(Color.RED);
                getDays()[cal.get(Calendar.WEEK_OF_MONTH)][cal.get(Calendar.DAY_OF_WEEK)-1].setPrevNextMonth(false);
            }
            
            int x=0;
            int xx=0;
            //obliczenie ile jest widocznych ostatnich dni poprzedniego miesiąca
            out_for:
            for (int i=0;i<getDays().length;i++)
                for (int j=0;j<getDays()[i].length;j++){
                    if (getDays()[i][j].getDayInMonth()!=0) {
                        break out_for;
                    }
                    else x++;
                }
            //Wypisanie ostatnich dni poprzedniego miesiąca
            cal.set(getYear(), getMonth()-2,1);
            xx=cal.getActualMaximum(Calendar.DAY_OF_MONTH);
            out_f3:
            for (int i=0;i<getDays().length;i++)
                for(int j=0;j<getDays()[i].length;j++){
                    int y=getYear(),m=getMonth()-1;
                    if (m==0) {y=getYear()-1; m=12;}
                    getDays()[i][j].setYearMonthDay(y, m, xx-x+1);
                    if (j==0) getDays()[i][j].setDayColor(Color.RED);
                    getDays()[i][j].setPrevNextMonth(true);
                    x--;
                    if (x<=0) break out_f3;
                }

            
            //obliczenie ile jest widocznych pierwszych dni następnego miesiąca
            x=0;
            out_for2:
            for(int i=getDays().length-1;i>=0;i--)
                for(int j=getDays()[i].length-1;j>=0;j--){
                    if(getDays()[i][j].getDayInMonth()!=0){
                        break out_for2;
                    }
                    else x++;
                }
            //Wypisanie pierwszych dni następnego miesiąca
            for_4:
            for (int i=getDays().length-1;i>=0;i--)
                for(int j=getDays()[i].length-1;j>=0;j--){
                    int y=getYear(),m=getMonth()+1;
                    if (m>12) {y=getYear()+1;m=1;}
                    getDays()[i][j].setYearMonthDay(y, m, x--);
                    if (j==0) getDays()[i][j].setDayColor(Color.RED);
                    getDays()[i][j].setPrevNextMonth(true);
                    if (x<=0) break for_4;
                }

            
        }
        
        //public void setDay(CalendarDay d, int nday){}
        public CalendarDay getCalendarDay(int day){
            CalendarDay d=null;
            out_for:
            for (int i=0; i<getDays().length;i++)
                for (int j=0;j<getDays()[i].length;j++){
                    if (getDays()[i][j].getDayInMonth() == day) {
                        if (!days[i][j].isPrevNextMonth()){//czy jest to dzień z tego miesiąca
                            d=getDays()[i][j];                  // a nie np 31 z poprzedniego miesięca
                            break out_for;
                        }
                    }
                }
            return d;
        }

        @Override
        public Class<?> getColumnClass(int columnIndex) {
            return getValueAt(0, columnIndex).getClass();
        }

        public void setMonth(int month) {
            this.month = month;
            countDays();
        }

        public void setYear(int year) {
            this.year = year;
            countDays();
        }

        public int getMonth() {
            return month;
        }

        public int getYear() {
            return year;
        }

        public CalendarDay[][] getDays() {
            return days;
        }

        public boolean isEditable() {
            return editable;
        }

        public void setEditable(boolean editable) {
            this.editable = editable;
        }
    }//end CalendarDataModel
    public static void main (String[] args){
        JFrame frm=new JFrame("Harmonogram");
        Schedule sch=new Schedule();
        frm.add(sch);
        frm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frm.setVisible(true);
        frm.pack();
        
        
        //TESTOWE DANE
        sch.addToYearComboBox(2007);
        sch.addToYearComboBox(2007);
        sch.addToMonthComboBox(1);
        sch.addToYearComboBox(2008);
        sch.addToYearComboBox(2009);
        for(String s:monthNames)
            sch.monthComboBox.addItem(s);
        
        sch.getCalendarDataModel().setEditable(true);
        
    }

}
